library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity diceRoller is
   Port (
       clk : in STD_LOGIC;
       KEY : in std_logic_vector(3 downto 0); -- roll key
       dice_value : out INTEGER;  -- Current value of the die
		 HEX0, HEX1, HEX2, HEX3, HEX4, HEX5, HEX6, HEX7 : out STD_LOGIC_VECTOR(6 downto 0);
       state : out STD_LOGIC_VECTOR(1 downto 0)  -- FSM state output for debugging
   );
end diceRoller;

architecture Behavioral of diceRoller is
type segPatternArray is array(0 downto 9) of STD_LOGIC_VECTOR(6 downto 0);

constant segPatterns : segPatternArray := (
      "1000000", -- 0
      "1111001", -- 1
      "0100100", -- 2
      "0110000", -- 3
      "0011001", -- 4
      "0010010", -- 5
      "0000010", -- 6
      "1111000", -- 7
      "0000000", -- 8
      "0010000"  -- 9
   );


   type state_type is (IDLE, ROLLING, STOPPING, DONE);
	
   signal current_state, next_state : state_type := IDLE;
   signal counter : INTEGER := 0;
   signal roll_count : INTEGER := 0;
	signal numOfSides : INTEGER := 6;
	signal numOfDice : INTEGER := 1;

begin

   process(clk)
   begin
       if rising_edge(clk) then
           current_state <= next_state;
       end if;
   end process;

   process(current_state, KEY(3), roll_count)
   begin
	case current_state is
		when IDLE =>
		if KEY(3) = '1' then
			next_state <= ROLLING;
			counter <= 1;
			roll_count <= 0;
		else
			next_state <= IDLE;
		end if;
		when ROLLING =>
		counter <= counter + 1;
		if counter > numOfSides then
			counter <= 1;
		end if;
		roll_count <= roll_count + 1;
		if roll_count > numOfSides * 2 then
			next_state <= STOPPING;
		else
			next_state <= ROLLING;
		end if;
		when STOPPING =>
		generateStopTimes : for i in 1 to numOfDice generate
			if stopTimes(i) = 0 then
				stopTimes(i) <= counter + (i * 10);
			elsif counter >= stopTimes(i) then
				dice_stopped(i) <= '1';
			end if;
		end generate generateStopTimes;
			if dice_stopped <= (others := 1) then
				next_state <= DONE;
			end if;
			when DONE =>
			if KEY(3) = '0' then
				next_state <= IDLE;
			else
				next_state <= DONE;
         end if;
       end case;
   end process;

   dice_value <= counter;

--	U1 : configureDice
--	port map(
--		numOfDice => numOfDice,
--		selection => KEY(1)
--	);
	
	process(counter)
	begin
		if (counter >= 0) and (counter <= 9) then
			HEX0 <= segPatterns(counter);
		else
			HEX0 <= "1111111";
		end if;
	end process;

	
   -- You can duplicate the above process for additional displays (HEX1, HEX2, etc.)
   -- 	based on the value of 'counter' or another signal representing the dice values.
	
end Behavioral;
